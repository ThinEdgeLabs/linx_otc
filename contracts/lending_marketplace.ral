Contract LendingMarketplace(
  loanTemplateId: ByteVec,   // Contract ID of the loan template
  mut totalLoans: U256,      // Total number of loans created
  mut feeRate: U256,         // Fee rate for borrowing, in basis points
  mut lendingEnabled: Bool,   // Flag to enable or disable lending
  upgradeDelay: U256,
  mut owner: Address,
  mut newOwner: Address,
  mut upgradeCommenced: U256,
  mut newCode: ByteVec,
  mut newImmFieldsEncoded: ByteVec,
  mut newMutFieldsEncoded: ByteVec
) extends LendingMarketplaceUtils(), Upgradable(upgradeDelay, owner, newOwner, upgradeCommenced, newCode, newImmFieldsEncoded, newMutFieldsEncoded) {

  // Mapping to store tokens that we collect fees in
  mapping[ByteVec, Bool] feeTokens

  event LoanCreated(loanId: ByteVec, id: U256, by: Address, timestamp: U256)
  event LoanDetails(loanId: ByteVec, lendingTokenId: ByteVec, collateralTokenId: ByteVec, lendingAmount: U256, collateralAmount: U256, interestRate: U256, duration: U256, lender: Address)
  event LoanCancelled(loanId: ByteVec, by: Address, timestamp: U256)
  event LoanPaid(loanId: ByteVec, by: Address, timestamp: U256)
  event LoanAccepted(loanId: ByteVec, by: Address, timestamp: U256)
  event LoanLiquidated(loanId: ByteVec, by: Address, timestamp: U256)

  enum ErrorCodes {
    LendingDisabled = 0
    LenderAllowedOnly = 1
    BorrowerAllowedOnly = 2
    LenderNotAllowed = 3
    InvalidLendingAmount = 4
    InvalidCollateralAmount = 5
    InvalidInterestRate = 6
    InvalidDuration = 7
  }

  pub fn getTotalLoans() -> U256 { return totalLoans }
  pub fn getFeeRate() -> U256 { return feeRate }

  @using(preapprovedAssets = true, checkExternalCaller = false, updateFields = true)
  pub fn createLoan(lendingTokenId: ByteVec, collateralTokenId: ByteVec, lendingAmount: U256, collateralAmount: U256, interestRate: U256, duration: U256) -> (Address) {
    assert!(lendingEnabled == true, ErrorCodes.LendingDisabled)
    assert!(lendingAmount > 0, ErrorCodes.InvalidLendingAmount)
    assert!(collateralAmount > 0, ErrorCodes.InvalidCollateralAmount)
    assert!(interestRate > 0, ErrorCodes.InvalidInterestRate)
    assert!(duration > 0, ErrorCodes.InvalidDuration)

    let lender = callerAddress!()

    // Checking for overflow
    let _ = calculateTotalInterestPayment(lendingAmount, interestRate, duration)

    let key = toByteVec!(totalLoans)
    let id = totalLoans
    let (encodeImmutableFields, encodeMutableFields) = Loan.encodeFields!(
      id,
      lender,
      lendingTokenId,
      collateralTokenId,
      selfContractId!(),
      lendingAmount,
      collateralAmount,
      interestRate,
      duration,
      nullContractAddress!(),
      0
    )
    let loanId = copyCreateSubContract!{lender -> ALPH: minimalContractDeposit!(), lendingTokenId: lendingAmount}(
      key, loanTemplateId, encodeImmutableFields, encodeMutableFields
    )
    totalLoans = totalLoans + 1

    emit LoanDetails(loanId, lendingTokenId, collateralTokenId, lendingAmount, collateralAmount, interestRate, duration, lender)
    emit LoanCreated(loanId, id, lender, blockTimeStamp!())

    return contractIdToAddress!(loanId)
  }

  @using(preapprovedAssets = true)
  pub fn borrow(loanId: ByteVec) -> () {
    let loan = Loan(loanId)
    let caller = callerAddress!()
    let lender = loan.getLender()
    checkCaller!(caller != lender, ErrorCodes.LenderNotAllowed)

    let collateralTokenId = loan.getCollateralTokenId()
    let collateralAmount = loan.getCollateralAmount()
    loan.borrow{caller -> collateralTokenId: collateralAmount}(caller)

    emit LoanAccepted(loanId, caller, blockTimeStamp!())
  }

  pub fn cancelLoan(loanId: ByteVec) -> () {
    let loan = Loan(loanId)
    let lender = loan.getLender()
    checkCaller!(callerAddress!() == lender, ErrorCodes.LenderAllowedOnly)
    loan.cancel()
    emit LoanCancelled(loanId, callerAddress!(), blockTimeStamp!())
  }

  @using(preapprovedAssets = true)
  pub fn repayLoan(loanId: ByteVec) -> () {
    let loan = Loan(loanId)
    let borrower = loan.getBorrower()
    let lendingTokenId = loan.getLendingTokenId()
    let loanAmount = loan.getLendingAmount()
    let interest = loan.getInterest()
    let caller = callerAddress!()
    checkCaller!(caller == borrower, ErrorCodes.BorrowerAllowedOnly)
    loan.repay{caller -> lendingTokenId: loanAmount + interest}()
    emit LoanPaid(loanId, caller, blockTimeStamp!())
  }

  pub fn liquidateLoan(loanId: ByteVec) -> () {
    let loan = Loan(loanId)
    let lender = loan.getLender()
    checkCaller!(callerAddress!() == lender, ErrorCodes.LenderAllowedOnly)
    loan.liquidate()
    emit LoanLiquidated(loanId, callerAddress!(), blockTimeStamp!())
  }

  @using(updateFields = true)
  pub fn updateFeeRate(value: U256) -> () {
    assertOnlyOwner(callerAddress!())

    feeRate = value
  }

  @using(updateFields = true)
  pub fn pauseLending() -> () {
    assertOnlyOwner(callerAddress!())
    lendingEnabled = false
  }

  @using(updateFields = true)
  pub fn enableLending() -> () {
    assertOnlyOwner(callerAddress!())
    lendingEnabled = true
  }

  @using(assetsInContract = true, preapprovedAssets = true)
  pub fn withdraw(to: Address, tokenId: ByteVec, amount: U256) -> () {
    assertOnlyOwner(callerAddress!())

    if (callerAddress!() != to) {
      transferToken!(callerAddress!(), to, ALPH, dustAmount!())
    }

    transferTokenFromSelf!(to, tokenId, amount)
  }

  @using(payToContractOnly = true, preapprovedAssets = true, checkExternalCaller = false)
  pub fn deposit(tokenId: ByteVec, amount: U256) -> () {
    transferTokenToSelf!(callerAddress!(), tokenId, amount)
  }

  @using(preapprovedAssets = true)
  pub fn addFeeToken(tokenId: ByteVec) -> () {
    assertOnlyOwner(callerAddress!())
    feeTokens.insert!(callerAddress!(), tokenId, true)
  }

  pub fn removeFeeToken(tokenId: ByteVec) -> () {
    assertOnlyOwner(callerAddress!())
    feeTokens.remove!(callerAddress!(), tokenId)
  }

  pub fn isFeeToken(tokenId: ByteVec) -> Bool {
    return feeTokens.contains!(tokenId)
  }
}
